
var path = require('path') 
, fs = require('fs')
, urlUtil = require('url')
, async = require('async')
, mkdirp = require('mkdirp')
, Q = require('q')
, _ = require('underscore')
, cheerio = require('cheerio')
, common = require('./lib/common')
, Cache = require('./lib/cache')
, http = require('http-get')

/**
* init an instance of the Scraper
*/
module.exports.init = function(options){
	return new Scraper(options);
}
module.exports.common = common;



/**
* Constructor
*/

function Scraper(options){
	
	var defaultOptions = {
		cc:1, 		
		delay:5, 
		timeout:60*000,
		tries: 1,  	
		proxy: false,
		proxies:[],
		proxy_file: path.join(__dirname, '../proxy.txt'), 
		proxy_auth:'',		
		cache: false,
		dir: path.join(__dirname, "../")
	};
		
	this.options = options || {};
	if(options.proxy_file || options.proxy_db || options.proxy_auth || options.proxies){
		//smartly enable proxy
		this.options.proxy = true;
	}
	if(options.dir && options.cache === undefined) this.options.cache = true; //smartly enable cache
	
	//override default optiosn with custom options
	this.options = common.mergeObjs(this.options, defaultOptions); 
	
	//setup scraper's properties
	this.dir = this.options.dir;
	this.proxies = this.options.proxies || [];
	
	if(!fs.existsSync(this.dir)) mkdirp.sync(this.dir);
	
	if(this.options.cache) this.cache = new Cache({location: path.join(this.dir, 'cache')})
		
	
	this.__loadProxies();
	
	this.request = require('request');
	var self = this;
	var worker = function(options, cb){
		self.__doLoad(options.url, options.options).then(function($){			
			cb();//indicate to the queue that this request is done				
			options.handler(null, $); //pass response data to handler
			
		}).fail(function(err){
			cb();//indicate to the queue that this request is done
			options.options.tries--;
			//try to re-do this request
			if(options.options.tries > 0){
				//re-queue
				console.log("retrying...")
				self.queue.push(options);
			}else{
				//no more try available
				options.handler(err, null); //pass response data to handler
			}
			
		})
	}
	this.queue = async.queue(worker, this.options.cc);
	
}

//*** API ****

//support: load(url), load(options), or load(url, options)
Scraper.prototype.load = function(url, options){
	if(typeof url === 'object'){
		//case: load(options)
		options = url;
		url = options.url;
	}
	options = options || {}
	url = url || '';	
	if(options.form) options.method = options.method || 'POST';		
	if(url.contains('http://localhost') || url.contains('127.0.0.1')) options.proxy = false;
	if(!options.tries) options.tries = this.options.tries || 1; //setup the maximum number of tries for this request
	
	var deferred = Q.defer();
	this.queue.push({url:url, options:options, handler: function(err, $){
		if(err) 
			deferred.reject(err);
		else
			deferred.resolve($);
	}})
	
	return deferred.promise;
}

Scraper.prototype.pagin = function(options){
	require('./lib/pager').create({
		sp: this,
		init: options.init, 
		loadedHandler: options.loaded, 
		doneHandler: options.done || function(err){
			if(err) console.log(err);
		}
	}).start();	
}

Scraper.prototype.save = function(item, filename){
	filename = filename || "result.csv";
	var fullPath = path.resolve(this.dir, filename);
	
	if(!this.keys) this.keys = [];
	if(this.keys.indexOf(fullPath) === -1 && fs.existsSync(fullPath)){
		//first time save to this file
		fs.unlinkSync(fullPath);
		this.keys.push(fullPath);
	}
	common.savecsv(item, {path: fullPath})
}

Scraper.prototype.download = function(options){
	var sp = this;
	var def = Q.defer();
	var file = path.resolve(sp.dir, options.file);
	var imagedir = path.resolve(file, '..');
	if(!fs.existsSync(imagedir)) mkdirp.sync(imagedir);
	
	fs.exists(file, function(exist){
		if(exist){
			def.resolve();
		}else try{
			http.get({url: options.url}, file, function(err, result){
				if(err) def.reject(err); else def.resolve();
			})
		}catch(err){
			def.reject(err);
		}
	})
	
	return def.promise;
	
}

//***-- end of API ***

/**
* load given url using Mikeal's Request object
*/
Scraper.prototype.__doLoad = function(url, options ){	
	var deferred = Q.defer();	
	options.url = url;
	
	//doc passed in
	if(options.doc){
		var $ = cheerio.load(options.doc);
				
		//make cheerio object xpath-able
		_.extend($, require('./lib/xpath'));
		
		//resolve all relative links to absolute
		$('a').each(function(i, el){
			var old = $(el).attr('href');
			if(old && old.length && !old.contains('javascript') && !old.contains('mailto:') && old[0] !== '#'){
				$(this).attr('href', urlUtil.resolve(url, old))
			}
			
		})
		$('form').each(function(i, el){
			var old = $(el).attr('action');
			if(old && old.length && !old.contains('javascript') && old[0] !== '#'){
				$(this).attr('action', urlUtil.resolve(url, old))
			}
			
		})
		//if(res.statusCode !== 200) {console.log(res);process.exit();}					
		
		deferred.resolve($);
		return deferred.promise;
		
	}
	
	//try reading from cache first
	if(this.options.cache && this.cache.exists(options)){				
		this.cache.read(options).then(function(body){			
			if(options.plain_text){
				//simply return body as text file
				deferred.resolve(body);					
			}else{
				//var cheerio = require('cheerio');
				var $ = cheerio.load(body);
				
				//make cheerio object xpath-able
				_.extend($, require('./lib/xpath'));
				
				//resolve all relative links to absolute
				$('a').each(function(i, el){
					var old = $(el).attr('href');
					if(old && old.length && !old.contains('javascript') && !old.contains('mailto:') && old[0] !== '#'){
						$(this).attr('href', urlUtil.resolve(url, old))
					}
					
				})
				$('form').each(function(i, el){
					var old = $(el).attr('action');
					if(old && old.length && !old.contains('javascript') && old[0] !== '#'){
						$(this).attr('action', urlUtil.resolve(url, old))
					}
					
				})
				//if(res.statusCode !== 200) {console.log(res);process.exit();}					
				
				deferred.resolve($);					
			}
		}).fail(function(err){
			deferred.reject(err);
		})
		
		return deferred.promise;				
	}
	
	
	//load directly
	options.headers || (options.headers = {"User-Agent" : 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2'} );
	options.strictSSL = false;
	options.followAllRedirects = true;
	options.timeout = options.timeout || this.options.timeout;
	if(this.options.proxy && options.proxy !== false){
		var proxy = this.proxies[Math.floor( (Math.random() * this.proxies.length) + 1) - 1] || '';
		//proxy = "211.138.156.199:80";		
		options.proxy = proxy;
		
	}
	var sp = this;
	setTimeout(function(){		
		try{
			sp.request(options, function(err, res, body) {				
				var accept_codes = options.accept_codes || [];
				accept_codes.push(200);				
				if(err || accept_codes.indexOf(res.statusCode) === -1){				
					deferred.reject(err || new Error("httpcode: " +res.statusCode));				
				}else if(options.validate && !options.validate(body)){						
					deferred.reject(new Error("invalid doc"));
				}else{
					//success
					
					if(sp.options.cache) sp.cache.write(options, body);
					
					if(options.plain_text){
						//simply return body as text file
						deferred.resolve(body);					
					}else{
						//var cheerio = require('cheerio');
						var $ = cheerio.load(body);
						
						//make cheerio object xpath-able
						_.extend($, require('./lib/xpath'));
						
						//resolve all relative links to absolute
						$('a').each(function(i, el){
							var old = $(el).attr('href');
							if(old && old.length && !old.contains('javascript') && !old.contains('mailto:') && old[0] !== '#'){
								$(this).attr('href', urlUtil.resolve(url, old))
							}
							
						})
						$('form').each(function(i, el){
							var old = $(el).attr('action');
							if(old && old.length && !old.contains('javascript') && old[0] !== '#'){
								$(this).attr('action', urlUtil.resolve(url, old))
							}
							
						})
						//if(res.statusCode !== 200) {console.log(res);process.exit();}					
						
						deferred.resolve($);					
					}
				}
			});
		}catch(err){
			deferred.reject(err);
		}
	}, this.options.delay)	
	
	return deferred.promise;
	
 }
Scraper.prototype.__loadProxies = function(){
	if(this.options.proxy_db) return this.__loadProxies_from_mongodb();
	if(!this.options.proxy_file || !fs.existsSync(this.options.proxy_file)) return;
	//reset proxies
	this.proxies = [];
	var self = this;	
	fs.readFileSync(this.options.proxy_file).toString().split("\n")
	.forEach(function(proxy){
		proxy = proxy.trim();
		if(self.options.proxy_auth){
			proxy = 'http://' + self.options.proxy_auth + '@' + proxy;
		}else{
			proxy = 'http://' + proxy;
		}
		self.proxies.push(proxy);	
	})
	
}

Scraper.prototype.__loadProxies_from_mongodb = function(){
	if(!this.options.proxy_db) return;
	
	//reset proxies
	this.proxies = [];
	var self = this;	
	
	var mongoose = require('mongoose'),
	Proxy = mongoose.model('Proxy', {ip: {type: String, unique: true}, port: String, country: String, speed: Number, connection_time: Number, type: String, ano: String})
	console.log(this.options.proxy_db)
	mongoose.connect(this.options.proxy_db);
	Proxy.find({}).exec(function(err, proxies){
		if(err) return console.log(err);
		
		proxies.forEach(function(p){
			var proxy = [p.ip, p.port].join(':');
			proxy = 'http://' + proxy;
			self.proxies.push(proxy)
		})
		mongoose.connection.close();
		
	})
	
	
}



 
 